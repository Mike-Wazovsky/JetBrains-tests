# JetBrains-tests

# Automatic test oracle generation for SE/CT

## Task #1

_Can we automatically compare two random objects using equals method? If not, try to come up with an example when equals will not work._

В ответе будем исходить из того, что объект обладает определенными полями и для его сравнения мы желаем, проверить, одинаковое ли состояние у двух объектов. Без переопределения метода _equals()_ в классе объекта, к сожалению не получится таким образом сравнить объекты. В случае вызова кода obj1.equals(obj2), без переопределения метода, джава возьмет определение метода из класса Object, который выглядит следующим образом:

```java
public boolean equals(Object obj) {
   return (this == obj);
}
```

В языке java для объектов ''=='' означает сравнение по адресам памяти. Для двух одинковых по наполнению определенных объектов это приведет, к false. Отсюда можно вывести пример, при котором equals не сработает

```java
public class Foo {
    int x;
    String str;


    public static void main(String[] args) {

        Foo foo1 = new Foo();
        foo1.x = 1;
        foo1.str = "Pipi-pupi-papi";

        Foo foo2 = new Foo();
        foo2.x = 1;
        foo2.str = "Pipi-pupi-papi";

        System.out.println(foo1.equals(foo2));
    }
}
```

Результатом программы будет _false_.

## Task #2

_Do you have any alternative ideas of how we can compare two random objects for equality? Explain their pros and cons._

### 1. equals()

Мы можем переопределить метод equals() в классе, тем самым полностью определять, каким образом мы хотим сравнить объекты.

Pros: Возможность настраивать сравнение под конкретный класс, определять критерии сравнения самому.

Cons: Может занимать много усилий и кода. Необходимо уметь поддерживать критерии equals, такие как: обработка null, рефлексивность, симметричность, транзитивность сравнения. Дополнительную сложность могут вызывать рекурсивные структуры, классы у которых есть предки и наследники.

### 2. Objects.equals(Object o1, Object o2)

Можно так же воспользоваться статическим методом Objects.equals для сравнения двух объектов. Внутри он делает обработку null случаев и проверяет что o1 != null перед вызовом equals() метода у объекта. Не добавляет новой логики в само сравнение, но обрабатывает null кейсы за пользователя.

pros: хэндлит случаи, когда мы хотим иметь не строго обязательную дату в классе. Позволяет не ухудшать читаемость кода, обработками null случаев.

cons: какие-то особые минусы, отличные от прошлого пункта отсутствуют, так как метод использует нашу реализацию equals() и оборачивает её, делая предварительные проверки.
