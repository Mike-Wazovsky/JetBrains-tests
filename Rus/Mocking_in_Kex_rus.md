# Mocking in Kex

## Task #1  

_Can you think of a way to solve the described problem without using mocking frameworks?_

Мне в голову приходит вариант, при котором для построения symbolic execution дерева можно переписывать код тестируемой программы. Можно удалить использование класса foo. Например как в предоставленном случае переписывать вызовы абстрактных методов класса, заменяя их на неизвестные переменные. 

Для предоставленного примера получилось бы следующее:

```java
class FooCopy { 
    int x;
    int y;
    int foo;
}

class BarCopy {
    void bar(FooCopy f) {
        int res = f.foo; 
        if (res > 0) {
            System.out.println("Success"); 
        } else {
            System.out.println("Failure"); 
        }
    } 
}
```

Я могу предположить, что такое решение нарушает какие-то святые правила тестирования, например что менять код самого тестируемого объекта нельзя. В этом определенно есть проблема связанная с тем, что можно только больше багов сделать / процесс непосредственного тестирования исходного кода становится сложнее.

________________________________

Другой способ решения может использовать dummy. Вставлять простое, жёстко закодированное значение. Например для объектов из функции возвращать null, а для любого примитива возвращать значение по умолчанию.

```java
class FooCopy { 
    int x;
    int y;
    
    public int foo() { return 0};
}

class BarCopy {
    void bar(FooCopy f) {
        int res = f.foo(); 
        if (res > 0) {
            System.out.println("Success"); 
        } else {
            System.out.println("Failure"); 
        }
    } 
}
```

Основная проблема такого подхода в том, что покрытие деревом тестов всех путей программы может сильно обрезаться, например в предоставленном случае программа не сможет протестировать случай "Success".

## Task #2

Вероятно самая большая проблема возникнет из-за того, что mock обычно создает заглушки на методы, то есть даёт функционал класса, который Kex не подразумевает. Так же как я прочитал, например Mockito ставит заглушки в качестве конкретных значений, что может сильно сказаться на качестве результата.

В связи с этим вероятно придется либо научить Kex воспринимать методы в проессе алгоритма и так же ветвиться по этим методам, либо научить Мокер создавать моки, в которых результаты методов каким-либо образом зависят от полей. Например создавать неизвестную переменную _foo_res_ в классе, которая будет возвращаться при вызове метода _foo. Так вероятно Kex сумеет проветвиться по выводу метода функии, то есть как бы по переменной.



Прошу прощения, доделать третье тестовое до конца на неделе времени не хватило:)











